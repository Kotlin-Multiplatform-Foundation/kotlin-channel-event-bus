{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kotlin-channel-event-bus \ud83d\udd06","text":"<p>TODO - TBD - WIP</p> <p> </p>"},{"location":"#multi-keys-multi-producers-single-consumer-event-bus-backed-by-kotlinxcoroutineschannelschannels","title":"Multi-keys, multi-producers, single-consumer event bus backed by <code>kotlinx.coroutines.channels.Channel</code>s.","text":"<ul> <li> <p>A Kotlin Multiplatform library that provides a simple event bus implementation using   <code>kotlinx.coroutines.channels.Channel</code>s.   This is useful for UI applications where you want to send events to communicate between   different parts / scope of your application.</p> </li> <li> <p>This bus is thread-safe to be used by multiple threads.   It is safe to send events from multiple threads without any synchronization.</p> </li> <li> <p><code>ChannelEvent.Key</code> will be used to identify a bus for a specific type of events.   Each bus has a <code>Channel</code> to send events to and a <code>Flow</code> to receive events from.</p> </li> <li> <p>The <code>Channel</code> is unbounded (<code>Channel.UNLIMITED</code> - default) or conflated <code>Channel.CONFLATED</code>.   The <code>Flow</code> is cold and only one collector is allowed at a time.   This make sure all events are consumed.</p> </li> </ul>"},{"location":"#author-petrus-nguyen-thai-hoc","title":"Author: Petrus Nguy\u1ec5n Th\u00e1i H\u1ecdc","text":"<p>Liked some of my work? Buy me a coffee (or more likely a beer)</p> <p></p>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>// Create your event type\ndata class AwesomeEvent(val payload: Int) : ChannelEvent&lt;AwesomeEvent&gt; {\n  override val key get() = Key\n\n  companion object Key : ChannelEventKey&lt;AwesomeEvent&gt;(AwesomeEvent::class)\n}\n\n// Create your bus instance\nval bus = ChannelEventBus()\n\n// Send events to the bus\nbus.send(AwesomeEvent(1))\nbus.send(AwesomeEvent(2))\nbus.send(AwesomeEvent(3))\n\n// Receive events from the bus\nbus\n  .receiveAsFlow(AwesomeEvent) // or bus.receiveAsFlow(AwesomeEvent.Key) if you want to be explicit\n  .collect { e: AwesomeEvent -&gt; println(e) }\n</code></pre>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>jvm</code> / <code>android</code>.</li> <li><code>js</code> (<code>IR</code>).</li> <li><code>Darwin</code> targets:</li> <li><code>iosArm64</code>, <code>iosArm32</code>, <code>iosX64</code>, <code>iosSimulatorArm64</code>.</li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosX86</code>, <code>watchosSimulatorArm64</code>.</li> <li><code>tvosX64</code>, <code>tvosSimulatorArm64</code>, <code>tvosArm64</code>.</li> <li><code>macosX64</code>, <code>macosArm64</code>.</li> </ul>"},{"location":"#docs","title":"Docs","text":"<p>TODO - TBD - WIP</p>"},{"location":"#sample","title":"Sample","text":"<ul> <li>Android Compose sample:   an Android app using Compose UI to show how to use the library.   It has two nested navigation graphs: <code>RegisterScreen</code> and <code>HomeScreen</code>.</li> </ul> <p>In <code>RegisterScreen</code>, we have 3 steps (3 screens) to allow user to input their information, step by   step.   - A <code>RegisterSharedViewModel</code> (bound to <code>RegisterScreen</code> navigation graph scope) is used     to hold the whole state of the registration process.     It observes events from the <code>ChannelEventBus</code> and update the state accordingly.</p> <ul> <li>Each step screen has a <code>ViewModel</code> to hold the state of the screen, and will send events to     the <code>ChannelEventBus</code>,     then the <code>RegisterSharedViewModel</code> will receive those events and update the state.</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>TODO - TBD - WIP</p>"},{"location":"#license","title":"License","text":"<pre><code>TODO - TBD - WIP\n</code></pre>"}]}